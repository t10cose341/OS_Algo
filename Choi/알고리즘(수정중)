data = [{'id': '1', 'at': 0, 'bt': 3, 'pr' : 1},
        {'id': '2', 'at': 1, 'bt': 6, 'pr' : 2}, 
        {'id': '3', 'at': 4, 'bt': 4, 'pr' : 3},
        {'id': '4', 'at': 6, 'bt': 2, 'pr' : 4}]
#FCFS
fcfs = []
indx = 0
for i in data:
    fcfs.append([i['at'], i['id'], indx])
    indx += 1
fcfs.sort()
processing_time = 0
for j in fcfs:
    processing_time += data[j[2]]['bt']
    print(processing_time)
#SJF
sjf = []
indx = 0
curr_time = 0
for i in data:
    sjf.append([i['bt'], i['at'], indx])
    indx += 1
sjf.sort()
processing_time1= 0
for j in range(len(sjf)):
    if (sjf[j][1] == 0):
        temp = sjf[0]
        sjf[0] = sjf[j]
        sjf[j] = temp
for k in range(len(sjf)):
    processing_time1 += sjf[k][0]
    print(processing_time1)
#SRTF
srtf = []
indx = 0
for i in data:
    srtf.append([i['at'], i['bt'],indx])
    indx += 1
srtf.sort()
rq = []
processing_time2 = 0
for j in range(len(srtf)):
    if(srtf[j][1] >= srtf[j+1][1]):
        rq1 = srtf[j][1] - srtf[j+1][1]
        rq.append(rq1)
    else:
        processing_time2 += srtf[j][1]
    print(processing_time2)
#RR
tq = 2
rr = []
indx = 0
processing_time3 = 0
flag = True
for i in data:
    rr.append([i['at'], i['bt'], indx])
    indx += 1
while flag:
    for i in range(len(rr)):
        bt = rr[i][1]
        if bt != 0 and rr[i][0] < processing_time3 or processing_time3 == 0:
            if bt > tq:
                rr[i][1] -= tq
                processing_time3 += tq
            else:
                rr[i][1] = 0
                processing_time3 += bt
                data[rr[i][2]]['ct'] = processing_time3
        print(processing_time3)
    flg = True
    for i in rr:
        if not i[1] == 0:
            flg = False
    if flg:
        flag = False
 #Nonpreempptive-priority
prior = []
indx = 0
processing_time4 = 0
for i in data:
    prior.append([i['pr'], i['at'], i['bt'], indx])
    indx += 1
prior.sort()
processing_time4 = 0
for j in range(len(prior)):
    processing_time4 += prior[j][2]
    print(processing_time4)
#Preemptive-priority

def find_max_prior_arrived(curr_time, lst):
    lst.sort(reverse=True)
    for i in lst:
        if curr_time >= i[1]:
            return i[-1], True

def all_done(lst):
    for i in lst:
        if i[2] != 0:
            return False
    return True

def reduce_bt(indx, lst):
    for i in range(len(lst)):
        if lst[i][-1] == indx:
            lst[i][2] -= 1
            if lst[i][2] == 0:
                del lst[i]
                return lst, True
    return lst, False
prior = []
indx = 0
curr_time = 0
for i in data:
    prior.append([i['pr'], i['at'], i['bt'], indx])
    indx += 1
prior.sort(reverse=True)
while not all_done(prior):
    index, has_arrived = find_max_prior_arrived(curr_time, prior)
    if has_arrived:
        curr_time += 1
        prior, is_done = reduce_bt(index, prior)
        if is_done:
            data[index]['ct'] = curr_time
